\chapter[Model Exploration by Confidence]{Model Exploration by Confidence with Completely Specified Counterexamples}
\label{cha:model-expl-conf}

We have seen how we can extend our understanding of attribute exploration to include the
possibility to explore implications which enjoy a high confidence in some given formal
context.  In this chapter we want to extend this generalization of attribute exploration
even further to be able to explore GCIs with high confidence in finite interpretations.
The basis for this extension will be Distel's \emph{model exploration}
algorithm~\cite{Diss-Felix}, an extension of attribute exploration to explore valid GCIs
of finite interpretations.

Model exploration, similarly to attribute exploration, assumes that a certain domain of
interest is representable by a finite interpretation $\mathcal{I}_{\mathsf{back}}$, which
we shall call the \emph{background interpretation} of the exploration process.  However,
we assume that this interpretation is not directly accessible, but instead we have given
an expert that allows us to decide whether certain GCIs are valid in
$\mathcal{I}_{\mathsf{back}}$ or not.  In addition, if a given GCI $C \sqsubseteq D$ is
not valid in $\mathcal{I}_{\mathsf{back}}$, then the expert provides a counterexample for
$C \sqsubseteq D$ in a suitable way.

The principal way how model exploration now works is again very akin to attribute
exploration.  Given a finite \emph{connected subinterpretation} $\mathcal{I}$ of
$\mathcal{I}_{\mathsf{back}}$ and a set $\mathcal{B}$ of valid GCIs of
$\mathcal{I}_{\mathsf{back}}$, the algorithm successively generates valid GCIs $C
\sqsubseteq D$ of $\mathcal{I}$ which do not follow from $\mathcal{B}$ and presents them
to some expert.  If the expert confirms $C \sqsubseteq D$, then it is added to
$\mathcal{B}$.  If the expert rejects $C \sqsubseteq D$, then she provides a
counterexample to it in the form of a connected subinterpretation of
$\mathcal{I}_{\mathsf{back}}$, which is added to $\mathcal{I}$.  Since $\mathcal{I}$ and
$\mathcal{B}$ thus play the same role as the working context and the set of known
implications during attribute exploration, we shall refer to them as the \emph{working
  interpretation} and the \emph{set of known GCIs}, respectively.  If no more GCIs can be
generated to be asked to the expert the algorithm stops.  It can be shown that at this
point, the set $\mathcal{B}$ is a finite base of $\mathcal{I}_{\mathsf{back}}$.

The foregone description already suggests that there are some difficulties in transferring
attribute exploration to the setting of GCIs and finite interpretations.  The most
apparent is that the set of GCIs we potentially have to cover is infinite, as the set of
valid GCIs of $\mathcal{I}_{\mathsf{back}}$ is infinite.

The other problem is that validity of GCIs in interpretations deploy a \emph{closed-world}
semantics: if an element $x \in \Delta^{\mathcal{I}}$ of a (finite) interpretation
$\mathcal{I} = (\Delta^{\mathcal{I}}, \cdot^{\mathcal{I}})$ does not have an $r$-successor
in $\mathcal{I}$, for some $r \in N_{R}$, then it is assumed that $x$ \emph{does not have}
$r$-successors, instead of just assuming that these $r$-successors are not specified, but
still could exist.  Therefore, if we add an element $x$ of $\mathcal{I}_{\mathsf{back}}$
as a counterexample for a GCI to our working interpretation $\mathcal{I}$, then we also
have to include \emph{all} its role successors (and their role successors, and so on),
even so they may not be needed as part the counterexample.  This is because otherwise
elements in $\mathcal{I}$ may serve as counterexamples to GCIs which are valid in
$\mathcal{I}_{\mathsf{back}}$, because missing information is considered as false
information.  The approach followed by Distel to account for this problem is to let the
expert provide \emph{connected subinterpretations} of $\mathcal{I}_{\mathsf{back}}$ as
counterexamples for GCIs.

Distel was now able to extend his algorithm for computing finite bases of $\mathcal{I}$
into an model exploration algorithm, and we shall introduce this algorithm with all
necessary details in \Cref{sec:model-expl-with}.  Based on this discussion, we shall
develop a model exploration algorithm that also includes GCIs with high confidence among
those proposed to the expert.  This algorithm, which we shall call \emph{model exploration
by confidence}, will be introduced in \Cref{sec:model-expl-with-1}, and its construction
will mimic the argumentation used by Distel for his model exploration algorithm.

The results presented in this section have been published previously in
\cite{Borc-LTCS-13-11}.

\section{Model Exploration with Valid GCIs}
\label{sec:model-expl-with}

In this section we shall introduce the model exploration algorithm devised by Distel to
allow to explore valid GCIs of finite interpretations~\cite[Chapter~6]{Diss-Felix}.  In
the next section, we shall then use the argumentation presented here and shall generalize
it to the setting of GCIs with high confidence in finite interpretations.

Model exploration is based on the result that bases of finite interpretations
$\mathcal{I}$ can be obtained from bases of their corresponding induced formal context
$\con K_{\mathcal{I}}$ (\Cref{thm:Felix-base-B3}).  Since attribute exploration arises
from the computation of the canonical base by adding suitable expert interaction (see
\Cref{sec:attr-expl}), one could think of obtaining an algorithm for model exploration by
adding suitable expert interaction during the computation of bases of $\con
K_{\mathcal{I}}$.  It shall turn out that this is indeed correct.

There is a technical problem, however, which does not arise in attribute exploration:
during attribute exploration, the set of attributes is fixed.  On the other hand, when we
add counterexamples to our current working interpretation $\mathcal{I}$ during model
exploration, then the attribute set $M_{\mathcal{I}}$ of the corresponding induced context
$\con K_{\mathcal{I}}$ may change, since it depends on the elements of $\mathcal{I}$:
recall that $M_{\mathcal{I}}$ was defined as
\begin{equation*}
  M_{\mathcal{I}} = N_{C} \cup \set{ \bot } \cup \set{ \exists r. X^{\mathcal{I}} \mid r
    \in N_{R}, X \subseteq \Delta^{\mathcal{I}}, X \neq \emptyset },
\end{equation*}
where $X^{\mathcal{I}}$ denotes the model-based most-specific concept description of $X$
in $\mathcal{I}$.

Thus, to allow to use attribute exploration as a basis for model exploration we need to
fix the attribute set, and the best way for this would be to use
$M_{\mathcal{I}_{\mathsf{back}}}$.  However, since we cannot access the background
interpretation $\mathcal{I}_{\mathsf{back}}$ directly, we cannot compute this set
completely.  However, it can be shown that we can compute the set
$M_{\mathcal{I}_{\mathsf{back}}}$ \emph{incrementally} during the computation, using the
fact that the expert confirms a certain type GCIs, and then use the parts of
$M_{\mathcal{I}_{\mathsf{back}}}$ we already know for the exploration process.

To explain how this can be done, we shall first discuss in \Cref{sec:grow-sets-attr} how
we can compute bases of formal contexts where the set of attributes is allowed to grow
during the computation.  Thereafter, we shall see in \Cref{sec:comp-bases-given} how we
can transfer this algorithm to the setting of computing finite bases of finite
interpretations $\mathcal{I}$, thus allowing the set $M_{\mathcal{I}}$ to be computed
successively during the computation.  Finally, we shall see in \Cref{sec:an-algor-expl}
how we can add expert interaction to avoid direct access to the underlying interpretation,
thus obtaining an algorithm that implements model exploration.

\subsection{Growing Sets of Attributes}
\label{sec:grow-sets-attr}

We want to find an algorithm that allows us to compute bases of formal contexts where the
attribute set is allowed to grow during the computation.  We can think of this situation
as not knowing the attributes of a formal context completely when we start the
computation, but instead more and more attributes are uncovered during the run of the
algorithm.

Obtaining such an algorithm is actually not that difficult.  For this let us consider how
\Cref{alg:canonical-base} computes the canonical base.  There, we use the Next Closure
algorithm to enumerate the premises of the canonical base of a given formal context $\con
K = (G, M, I)$, using some linear order $\leq_{M}$ on $M$.  If $M = \set{ m_{1}, \dots,
  m_{n} }$ and
\begin{equation*}
  m_{n} \leq_{M} m_{n-1} \leq_{M} \dots \leq_{M} m_{1},
\end{equation*}
then the Next Closure algorithm firstly enumerates all premises which are subsets of
$\emptyset$, then those which are subsets of $\set{ m_{1} }$, then those of $\set{ m_{1},
  m_{2} }$ and so on.  In particular, it will not consider an element $m_{k} \in M$ before
it has enumerated all premises which are subsets of $\set{ m_{1}, \dots, m_{k-1} }$.

We can exploit this idea for our purpose of computing bases with growing sets of
attributes: if the attribute set in iteration $i$ is $M_{i}$, ordered by $\leq_{M_{i}}$,
and we are about to add some new attributes $m_{1}, \dots, m_{n}$ to $M_{i}$ to obtain
\begin{equation*}
  M_{i+1} := M_{i} \cup \set{ m_{1}, \dots, m_{n} },
\end{equation*}
then we define the linear order $\leq_{M_{i+1}}$ on $M_{i+1}$ by ordering the elements in
$M_{i} \subseteq M_{i+1}$ as before, \ie
\begin{equation}
  \label{eq:48}
  \leq_{M_{i}} = {\leq_{M_{i+1}}} \cap M_{i} \times M_{i},
\end{equation}
and requiring in addition that
\begin{equation}
  \label{eq:49}
  m_{j} \leq_{M_{i+1}} x
\end{equation}
is true for all $j \in \set{ 1, \dots, n }$ and $x \in M_{i}$.  In other words, we just
put the new elements \emph{before} the old elements.  In that way, the Next Closure
behaves as if the elements would have been there from the start, and computes the base as
desired.

\addfunctionname{base/growing-set-of-attributes}

\begin{figure}[tp]
  \begin{Algorithm}[Algorithm 8 from~\cite{Diss-Felix}]~ Computing a Base of a Formal
    Context with Growing Sets of Attributes and Background Knowledge%
    \label{alg:base/growing-set-of-attributes}
\begin{lstlisting}
define base/growing-set-of-attributes($\con K = (G, M, I)$, $\leq_{M}$, $\mathcal{S} \subseteq \Th(\con K)$)
  $i$ := 0
  $P_i$ := $\emptyset$
  $\mathcal{K}_i$ := $\emptyset$
  $\con K_i$ := $\con K$
  $M_i$ := $M$
  $\mathcal{S}_i$ := $\mathcal{S}$
  $\leq_{M_i}$ := $\leq_{M}$

  forever do
    read $\con K_{i+1} = (G, M_{i+1}, I_{i+1}) \text{ such that } M_i \subseteq M_{i+1}
\text{ and } I_i = I_{i+1} \cap M_i \times M_i$
    read $\mathcal{S}_{i+1} \text{ such that } \mathcal{S}_i \subseteq \mathcal{S}_{i+1} \subseteq \Th(\con K_{i+1})$
    choose ${\leq_{M_{i+1}}} \text{ such that (\ref{eq:48}) and (\ref{eq:49}) hold.}$

    $\mathcal{K}_{i+1}$ := $\set{ P_r \to (P_r)_{\con K_{i+1}}'' \mid P_r \neq
      (P_r)_{\con K_{i+1}}'', r \in \set{ 0, \ldots, i } }$

    $P_{i+1}$ := next-closure($M_{i+1}$, $\leq_{M_{i+1}}$, $P_{i}$, $\mathcal{K}_{i+1} \cup \mathcal{S}_{i+1})$
    if $P_{i+1} =$ nil exit

    $i$ := $i + 1$  
  end

  return $\mathcal{K}_i$  
end    
\end{lstlisting}  
  \end{Algorithm}
\end{figure}

An implementation of this idea is shown in \Cref{alg:base/growing-set-of-attributes}.
Here we start with some initial formal context $\con K_{0} = \con K = (G, M, I)$ and some
background knowledge $\mathcal{S}_{0} = \mathcal{S} \subseteq \Th(\con K)$.  Then, in
every iteration we allow to extend the current context $\con K_{i} = (G, M_{i}, I_{i})$ by
providing a new set $M_{i+1} \supseteq M_{i}$ of attributes and a new incidence relation
$I_{i+1} \subseteq M_{i+1} \times M_{i+1}$ which satisfies
\begin{equation*}
  I_{i} = I_{i+1} \cap M_{i} \times M_{i}.
\end{equation*}
This corresponds to our perception that we do not now the actual formal context of which
we want to compute a base of at the beginning, but instead uncover more and more parts
during the computation.

For this algorithm to make sense, we of course need to require that at a certain point all
of the formal context has been uncovered, \ie that for some $\ell \in \NN_{\geq 0}$ it is
true that $M_{\ell} = M_{i}$ for all $i \geq \ell$.  From this point on,
\Cref{alg:base/growing-set-of-attributes} behaves as \Cref{alg:canonical-base} for
computing the canonical base of a given formal context.

\begin{Theorem}[Theorems~6.2 and~6.3 from~\cite{Diss-Felix}]
  \label{thm:base-with-growing-set-of-attributes}
  Let $\con K = (G, M, I)$ be a finite formal context, $\leq_{M}$ a linear order on $M$,
  and $\mathcal{S} \subseteq \Th(\con K)$.  Then in a run of
  \Cref{alg:base/growing-set-of-attributes}, let $\ell \in \NN_{\ge 0}$ be such that
  $M_{\ell} = M_{i}$ for all $i \geq \ell$.  Then this run terminates.  If $n$ is the last
  iteration of this run, then $\mathcal{K}_{n}$ of $\con K_{n}$ with background knowledge
  $\mathcal{S}_{n}$.
\end{Theorem}

A difference to the classical computation of the canonical base as shown in
\Cref{alg:canonical-base} is that in the latter we only consider sets $P$ as premises for
implications which are closed under the currently known implications, but are not intents
of the given formal context.  In contrast to this,
\Cref{alg:base/growing-set-of-attributes} considers all sets $P_{i}$ which are closed
under the currently known implications, no matter whether they are intents of $\con K_{i}$
or not.  The reason for this that even if $P_{i}$ is an intent of $\con K_{i}$, it could
very well be that $P_{i}$ is not an intent of $\con K_{n}$ (where $n$ is the number of
iterations of the algorithm) because of attributes which have been introduced in $\con
K_{n}$, but were not present in $\con K_{i}$.  Since we cannot know whether $P_{i}$ will
be an intent of $\con K_{n}$ or not when we compute it, we have to consider it as well.
Otherwise, we cannot guarantee that $\mathcal{K}_{n}$ will be a base of $\con K_{n}$.

Unfortunately, the fact that we have to keep all those sets $P_{i}$ may lead to
$\mathcal{K}_{n}$ not being irredundant anymore.  This has been illustrated
in~\cite{Diss-Felix} by the following example.

\begin{Example}[Example~6.1 from~\cite{Diss-Felix}]
  \label{exp:non-redundant-bases}
  %
  \begin{figure}[tp]
    \centering
    \begin{equation*}
      \con K_0 = \con K_1 =
      \begin{array}{c | c}
        ~ & \text{A} \\
        \midrule
        1 & \times \\
        2 & 
      \end{array}
      \qquad
      \con K_2 = \con K_3 =
      \begin{array}{c|cc}
        ~ & \text{A} & \text{B} \\
        \midrule
        1 & \times & \\
        2 &        & \times
      \end{array}
      \qquad
      \con K_3 = \con K_4 = \con K_5 =
      \begin{array}{c|ccc}
        ~ & \text{A} & \text{B} & \text{C}\\
        \midrule
        1 & \times & & \times \\
        2 & & \times &
      \end{array}
    \end{equation*}
    \caption{Formal Contexts for \Cref{exp:non-redundant-bases}}
    \label{fig:example-context-1}
  \end{figure}
  %
  We consider the following run of \Cref{alg:base/growing-set-of-attributes} with input
  $\con K = \con K_0$ as shown in \Cref{fig:example-context-1}, and $\mathcal{S} =
  \mathcal{S}_0 = \emptyset = \mathcal{S}_1 = \ldots = \mathcal{S}_6$:
  \begin{equation*}
    \begin{array}{c|ccc}
      k & M_{k+1} \setminus M_k & \mathcal{L}_k & P_k \\
      \midrule
      0 & \emptyset      & \emptyset & \emptyset         \\
      1 & \emptyset      & \emptyset & \set{\text{A}}    \\
      2 & \set{\text{B}} & \emptyset & \set{\text{B}}    \\
      3 & \emptyset      & \emptyset & \set{\text{A}, \text{B}} \\
      4 & \set{\text{C}} & \set{\set{\text{A}} \to \set{\text{A},\text{C}},
        \set{\text{A},\text{B}} \to \set{\text{A}, \text{B}, \text{C}}} & \set{\text{C}}\\
      5 & \emptyset      & \set{\set{\text{A}} \to \set{\text{A},\text{C}},
        \set{\text{A},\text{B}} \to \set{\text{A}, \text{B}, \text{C}}, \set{\text{C}} \to
        \set{\text{A},\text{C}}} & \set{\text{A}, \text{B}, \text{C}}\\
      6 & \emptyset & \set{\set{\text{A}} \to \set{\text{A},\text{C}},
        \set{\text{A},\text{B}} \to \set{\text{A}, \text{B}, \text{C}}, \set{\text{C}} \to
        \set{\text{A},\text{C}}} & \text{\lstinline{nil}}
    \end{array}
  \end{equation*}
  In iterations 2 and 4, the new attributes B and C are added, as shown in
  Figure~\ref{fig:example-context-1}.  The algorithm terminates in iteration 6 with output
  $\mathcal{L}_6$, which is clearly non-redundant: the implication $\set{\text{A},
    \text{B}} \to \set{\text{A}, \text{B}, \text{C}}$ is entailed by $\set{\text{A}} \to
  \set{\text{A}, \text{C}}$.
\end{Example}

\subsection{Exploring Valid GCIs with Known Background Interpretation}
\label{sec:comp-bases-given}

\todo[inline]{Write: 13-11/4.3}

\subsection{An Algorithm for Exploring Interpretations}
\label{sec:an-algor-expl}

\todo[inline]{Write: 13-11/4.4}

\section{Model Exploration with Confident GCIs}
\label{sec:model-expl-with-1}

\todo[inline]{Write: 13-11/5}%

\subsection{Trusted and Untrusted Individuals}
\label{sec:trust-untr-indiv}

\subsection{Growing Sets of Attributes}
\label{sec:grow-sets-attr-1}

\subsection{Exploring Confident GCIs with Known Background Interpretation}
\label{sec:expl-conf-gcis}

\subsection{Exploring Confident GCIs with Expert Interaction}
\label{sec:expl-conf-gcis-1}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../main"
%%% End: 
